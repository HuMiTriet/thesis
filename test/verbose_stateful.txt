import unittest
from hypothesis import strategies as st
from hypothesis.stateful import RuleBasedStateMachine, rule, initialize

from multiprocessing import Process

from psutil import process_iter, AccessDenied
from signal import SIGTERM  # or SIGKILL

from server import create_app as create_server
from registrar import create_app as create_registrar
from client import create_app as create_client

import requests


# the class should receive a setup fixture defined in the conftest.py file
# how to pass a fixture to a stateful test?
class LockingTest(RuleBasedStateMachine):
    def __init__(self) -> None:
        super().__init__()

    @initialize()
    def setup(self):
        server_app = create_server()
        registrar_app = create_registrar()
        client_app = create_client()

        print("STARTING SERVER...")

        self.server_process = Process(
            target=server_app.run, kwargs={"port": 5000}
        )
        self.registrar_process = Process(
            target=registrar_app.run, kwargs={"port": 5001}
        )
        self.client_1_process = Process(
            target=client_app.run, kwargs={"port": 5002}
        )
        self.client_2_process = Process(
            target=client_app.run, kwargs={"port": 5003}
        )

        self.server_process.start()
        self.registrar_process.start()
        self.client_1_process.start()
        self.client_2_process.start()

    @rule(resource_id=st.characters(min_codepoint=65, max_codepoint=66))
    def get_resource_from_server(self, resource_id):
        response = requests.get(f"http://127.0.0.1:5000/{resource_id}")
        assert response.status_code == 200

    @rule(
        resource_id=st.characters(min_codepoint=65, max_codepoint=66),
        client_port=st.integers(min_value=5002, max_value=5003),
    )
    def client_lock(self, resource_id: str, client_port: int):
        # requests.delete(f"http://127.0.0.1:{client_port}/{resource_id}/lock")
        response = requests.post(
            f"http://127.0.0.1:{client_port}/{resource_id}/lock"
        )
        assert response.status_code == 200 or response.status_code == 401

    # Override the self.teardown method to kill the server
    def teardown(self):
        def _kill_process(ports: list[int]) -> None:
            for proc in process_iter():
                try:
                    for conns in proc.connections(kind="inet"):
                        if conns.laddr.port in ports:
                            proc.send_signal(SIGTERM)
                except AccessDenied:
                    pass

        self.server_process.terminate()
        self.registrar_process.terminate()
        self.client_1_process.terminate()
        self.client_2_process.terminate()

        _kill_process([5000, 5001, 5002, 5003])


LockingTestCase: unittest.TestCase = LockingTest.TestCase
