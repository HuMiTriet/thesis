\subsection{Fault Injection}
\label{subsec:fault_injection}


Fault injection is a crucial technique used in our study to test the robustness of our implemented algorithms. We introduce various fault scenarios into the system, and evaluate the algorithms' performance and response to these errors. 
The process of fault injection in our project can be broken down into two phases:

\begin{enumerate}
  \item \textbf{Preprocessing Phase:} This phase involves defining the faults
    and loading them into the proxy. These faults are predefined 
    errors that will be introduced into the system during the testing process. 
  \item \textbf{Execution Phase:} During this phase, the predefined faults are injected into the prototype during runtime. 
\end{enumerate}


\subsubsection{Preprocessing phase}
\label{subsubssec:preprocessing_phase}
The preprocessing phase sets the stage for fault injection by specifying the faults to be injected. 
To do this, all faults to be injected are stored in a JSON file named \textit{faults.json}.

Currently, there are two types of fault that can be specified:

\begin{multicols}{2}
  \begin{listing}[H]
    
  \begin{minted}{json}
  {
    "type": "delay",
    "name": "0.01",
    "condition": "True",
    "metadata": 0.01
  }
  \end{minted}
  \caption{Delay type fault}
  \label{code:json_delay}
\end{listing}

  \columnbreak

  \begin{listing}[H]
  \begin{minted}{json}
  {
    "type": "error",
    "name": "error_420",
    "condition": "True",
    "metadata": {
      "text": "dummy error",
      "status_code": 420
    }
  }
  \end{minted}
  \caption{Error type fault}
  \label{code:json_error}
\end{listing}
\end{multicols}

The fault will be load into the proxy at the start of testing using a pytest's 
fixture like the one in \ref{code:test_case_signature}.

Next the JSON file will be parsed and then sent to the proxy endpoint /fault:

\begin{listing}[H]
  \begin{minted}{python}
managerState = ManagerState()
@bp.route("/fault", methods=["POST"])
def fault_factory():
    all_data = request.get_json()
    for data in all_data:
        match data["type"]:
            case "delay":
                managerState.faults[name] = DelayFault(
                    #...
                )
            case "error":
                managerState.faults[name]  = ErrorFault(
                    #...
                )
            case _:
                return f'fault type {data["type"]} unknown', 406
    return "ok", 200
  \end{minted}
  \caption{The /fault endpoint deserialize the JSON data into fault objects}
\end{listing}


Since there are two types of faults, there are two corresponding two classes 
\textit{DelayFault} and \textit{ErrorFault} both inherited from \textit{Fault}
abstract class.

\begin{multicols}{2}
  \begin{listing}[H]
  \begin{minted}{python}
@dataclass
class DelayFault(Fault):
    #...
    async def execute(
        #...
    ): 
        if eval(self.condition):
            await asyncio.sleep(self.duration)
  \end{minted}
  \caption{Delay fault class}
\end{listing}

  \columnbreak

  \begin{listing}[H]
  \begin{minted}{python}
@dataclass
class ErrorFault(Fault):
    #...
    async def execute(
        #...
    ):
        if eval(self.condition):
            return self.text, self.status_code
  \end{minted}
  \caption{Error fault class}
\end{listing}
\end{multicols}

The two child class both has an execute function which uses python's eval to 
evaluate the string condition to see if they are applicable for the current request.

The eval can evalute condition basic such as the ones in \ref{code:json_delay} and
\ref{code:json_error}, or they can be more complex:

\begin{listing}[H]
  \begin{minted}{json}
"condition": "request.method == \"POST\" 
                and re.match(\".+/broadcast\", url) is not None  
                and request.get_json()[\"origin\"] == \"http://127.0.0.1:5002/\"",
  \end{minted}
  \caption{Condition targeting the broadcast request of a particular client}
\end{listing}

\subsubsection{Execution phase}

Inside the proxy there is a class: 
\begin{listing}[!ht]
  \begin{minted}{python}
@dataclass
class ManagerState:
    faults: dict[str, Fault] = field(
        default_factory=dict[str, Fault]
    )  # all of the possible faults
    faults_currently_injected: list[str] = field(
        default_factory=list[str]
    )  # the fault we are currently using
  \end{minted}
  \caption{Code snippet of the managerState class}
  \label{code:managerState}
\end{listing}

During the preprocessing phase (\ref{subsubssec:preprocessing_phase}), the 
\textit{faults} dictionary in the \textit{managerState} has already been populated 
with potential faults. In this phase, we proceed to populate the \textit{faults\_currently\_injected} 
list. This list serves to keep track of the faults that are presently in use.

There exist two methods to populate the \textit{faults\_currently\_injected} list, thereby enabling the corresponding faults to take effect.

The first method is to make an HTTP request to the proxy endpoint: 

\begin{listing}[H]
  \begin{minted}{python}
requests.post(
    "http://127.0.0.1:5001/inject",
    json={"fault": fault_names},
)
  \end{minted}
  \caption{Applying the fault by making an HTTP request to the proxy}
\end{listing}

Upon completion of the test, it's essential to send an HTTP DELETE request to the /inject endpoint in order to restore the proxy to its initial state.

Alternatively, for convenience in implementation, the \textit{fault\_injection} decorator can be employed:

\begin{listing}[H]
  \begin{minted}{python}
    
@fault_injection(["delay_0.01"])
def test_one_client_lock_with_small_delay():
  #... testing logic
  \end{minted}
  \caption{Applying the fault via fault\_injection decorator}
\end{listing}

The \textit{fault\_injection} decorator essentially wraps the original function. It automatically sends an HTTP POST request and, upon completion of the test, sends an HTTP DELETE request to the /inject endpoint. 

Given that every client's HTTP request is routed through the proxy, these requests will be interacting with the following endpoint:
\begin{listing}[!ht]
  \begin{minted}{python}
    @app.route(
        "/<path:url>",
        methods=["GET", "POST", "PUT", "DELETE"],
    )
    async def handler(url: str):
  \end{minted}
  \caption{Proxy endpoint which handles all routed HTTP requests}
  \label{code:handler}
\end{listing}

The proxy in listing \ref{code:handler} will then loop over every faults that is currently being used, and execute
those faults.

\begin{listing}[!ht]
  \begin{minted}{python}
if len(managerState.faults) != 0:
    for fault in managerState.faults_currently_injected:
        choosen_fault = managerState.faults[fault]
        #...
        choosen_fault.execute(request=request, url=url)
  \end{minted}
  \caption{Proxy loops over all currently injected faults and execute them}
  \label{code:fault_execute}
\end{listing}

When the \textit{execute()} method, as seen in \ref{code:fault_execute}, is called, it 
first checks via an eval statement whether the fault should be applied to the 
particular request. Therefore, not every fault is necessarily executed for every request.

Moreover, the \textit{DelayFault} and \textit{ErrorFault} are both subclasses of 
the abstract class Fault, which declares the abstract method \textit{execute()}. 
Consequently, when the method \textit{execute()} is invoked, the corresponding execution logic is managed by the respective subclasses, either \textit{DelayFault} or \textit{ErrorFault}.
