\chapter{\centering Distributed Mutex Algorithms}
\label{chap:algorithms}

\section{Safety and Liveness properties}
While constructing distributed systems, two fundamental concepts of computer science—Safety and Liveness—often emerge. Thus, understanding these principles has been instrumental in the development and testing of various mutex algorithms.


% \subsection{Safety}
A safety property guarantees that something bad will never happen. It's a 
property that states that the system will not reach a bad or undesirable state. 

As part of our algorithm development process, we employed fuzzy testing techniques, as described in Sections \ref{subsubsec:basic_hypothesis_tests} and \ref{subsubsec:stateful_testing}. This approach helped us ensure the absence of race conditions, where two clients could access the critical section simultaneously—a scenario that would violate the safety property.

% \subsection{Liveness}
A liveness property guarantees that something good will eventually happen. 
This means that the system will eventually reach a desirable or good state.

During the prototype development phase, we came across a situation where two clients made concurrent requests to access the same critical section. To maintain system liveness and prevent potential deadlock scenarios, we devised a strategy that utilized the clients' IDs as a deciding factor, or 'tiebreaker'. This mechanism determined which request would receive priority, thus ensuring that some progress would be made, aligning with the liveness property.

\section{Token Ring}
Token ring, initially introduced by IBM, is a computer networking technology 
employed to construct local area networks \cite{wiki_token_ring}. The term "token ring" 
can be used to describe either physical or logical topology. However, in the 
context of this specific project—where all nodes represent different processes 
running on a local host—we will use "token ring" to refer to the logical topology.

\subsection{Topology of the token ring}
The token ring algorithm, arguably the most straightforward concept among the three under discussion, operates by first positioning the nodes in a circular arrangement, forming a 'ring'. Initially, a token is randomly assigned to one node. This token is then continuously passed around the ring in one specific direction, as depicted in figure \ref{fig:token_ring_top}.

\begin{figure}[htbp]
  \centering
  \includesvg{images/token_ring.svg}
  \caption{Token ring's topology}
  \label{fig:token_ring_top}
\end{figure}

\subsection{How the algorithm works}
In our prototype's implementation of the token ring, when a client wishes to enter the critical section, it first transitions its internal state from the DEFAULT state to REQUESTING. 

Following this, three possible scenarios may unfold:

\begin{itemize}
  \item If the client does not possess the token, it will remain idle and wait.
  \item If the client does possess the token, but is not interested in entering the critical section, it will pass the token to the next client in the ring.
  \item If the client has the token and is also interested in entering the critical section, it will retain the token and proceed to enter the critical section.
\end{itemize}

While the token ring concept is relatively straightforward to grasp among the 
three algorithms we implemented in this prototype, it proved to be the most 
challenging in terms of practical implementation. Initially, we struggled to 
devise a method that allowed for the token to be passed without hanging/freezing the 
process that is currently holding the token. We managed to overcome this hurdle by creating a separate event loop tasked exclusively with handling the token-passing process.

\section{Ricart Agrawala}
The Ricart-Agrawala Algorithm is a permission-based method for ensuring mutual 
exclusion in a distributed system.

The beauty of the Ricart-Agrawala Algorithm lies in its democratic nature. No 
single process or node has overarching control or authority; rather, each process 
gets to have its turn at accessing the shared resource, while all the others are 
aware of who is in the critical section at any given time. This is achieved using 
a method of requesting and granting permission for access, alongside a system of 
logical clocks to establish an order of precedence among simultaneous requests.

\subsection{Logical Clock}
In general the Ricart-Agrawala algorithm needs to need to know which action occur 
before another action. At first glance we might be tempted to use a normal clock, 
or called physical clock, where the time is just real work timestamp for each action, 
e.g. Unix epoch time, etc.

However, there is a problem with this approach, because 
distributed systems consist of numerous independent nodes, each operating on their 
own physical clock. These clocks, despite synchronization efforts, can differ 
slightly due to various factors such as drift and network latency. These minor 
variations can lead to substantial inconsistencies when it comes to deciding the 
sequence of events, particularly in algorithms like Ricart-Agrawala where mutual 
exclusion is governed by timestamps.

\begin{figure}[H]
  \centering
  \includesvg{physical_clock.svg}
  \caption{Physical clock: count the number of seconds that has passed}
  \label{fig:physical_clock}
\end{figure}

\begin{figure}[H]
  \centering
  \includesvg{logical_clock.svg}
  \caption{Logical clock: count the number of events that has occurred}
  \label{fig:logical_clock}
\end{figure}

% \begin{itemize}
%   \item Physical clock: count the number of seconds that has passed
%   \item Logical clock: count the number of events that has occurred
% \end{itemize}

In the prototype implementation the logical clock is a counter variable that updates
every time an event has occurred.

\subsection{How the algorithm works}

If a process seeks to enter a critical section, it first sends a Request message to all other processes in the system. The recipient processes, under certain conditions, will send back a Reply. Once the initiating process has received enough Replies, it will proceed to enter the critical section.

In Ricart Agrawala, a process that has received a Request from another process will only 
reply in either:

\begin{itemize}
  \item The process itself is neither requesting nor is the critical section
  \item If the process is also requesting, the received request timestamp is smaller than its own request's timestamp.
\end{itemize}

The two conditions above is illustrated in \ref{fig:ricart_agrawala_seq}.

\begin{figure}[htbp]
  \centering
  \includesvg{ricart_agrawala_sequence.svg}
  \caption{sequence diagram of Ricart Agrawala algorithm}
  \label{fig:ricart_agrawala_seq}
\end{figure}

When P1 sends \textit{Request (T1)} Process P2 immediately \textit{reply} because it has not made any request yet 
or is in any critical section. Process P1 now has 1/2 replies needed.

Process P2 then sends \textit{Request (T2)} this time the timestamp is T2 because after P2 received 
\textit{Request (T1)} it updates its logical clock to T2. 

Process P1, now sees two requests its own \textit{Request (T1)} and P2's \textit{Request (T2)}
but since \textit{Request (T1)} has a smaller timestamp it will not send a reply to P2, and store
the deferred reply in a queue.

P3 then send a \textit{reply} to P1, now P1 has 2/2 replies needed, so it enters the critical 
section. P3 also send a reply to P2, but P2 only has 1/2 replies, so it waits for its turn.

Once P1 exited the critical section, it sends a reply message to all the deferred replies,
in this case it sends a reply to P2, P2 now has 2/2 replies. 

P2 enter the critical section

\section{Maekawa}
Differing from the Ricart-Agrawala algorithm above the Maekawa algorithm is a quorum based 
approach. A quorum, or a voting set, is a subset of total processes. Maekawa algorithm
is like Ricart-Agrawala but instead of asking all other process it just ask the members within
its quorum, this reduced the number of message being exchanged, thus being more efficient.

\subsection{Minimal Quorum}
Each quorum in the Maekawa algorithm must satisfy the two following properties:

\begin{itemize}
 \item Intersection Property: Every pair of voting sets has at least one process in common. 
 \item Majority Rule: Each process is part of its own voting set.
\end{itemize}
The intersection property ensures mutual exclusion because whenever two processes 
attempt to enter their critical sections simultaneously, the common process in their voting sets will only grant permission to one of them, thereby preventing simultaneous entry.

The majority rule allows each process to assert control over its own execution, giving it the power to request access to a resource and then release it when done.

To reduce the message complexity of the algorithm it is best that we use a minmal 
quorum. According to \cite{eth_quorum}: A quorum system $S$ is called \textbf{minimal}
if $\forall Q_1, Q_2 \in S: Q_1 \not\subset Q_2$.



\subsection{How to create a minimal quorum}

One way to construct a minimal quorum is to use a grid-based approach.

The steps to construct a minimal quorum are as follows:

\begin{enumerate}
\item Arrange all the client nodes into a square of side length $\sqrt{n}$, where $n$ is the total number of nodes.
\item The minimal quorum of a node comprises all the clients in the same row 
  and column as that node. An illustration of this is shown in Figure 
  \ref{fig:maekawa_minimal}, where the minimal quorum of client 1 is the set $\{1,2,4\}$.
\item Repeat the previous step for all clients.
\end{enumerate}


\begin{figure}[htbp]
  \centering
  \includesvg{maekawa_minimal_quorum.svg}
  \caption{Minimal quorum}
  \label{fig:maekawa_minimal}
\end{figure}


If the number of nodes, $n$, is not a perfect square, then some cells in the grid may be empty. Any such empty cells are not included in the quorum.\\

The details of how the algorithm operates have been omitted, as it functions in a manner similar to the Ricart-Agrawala algorithm. However, instead of requesting all nodes in the network to enter the critical section, the Maekawa algorithm only requests nodes within the same quorum.


