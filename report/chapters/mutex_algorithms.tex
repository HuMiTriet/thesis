\chapter{\centering Distributed Mutex Algorithms}
\label{chap:algorithms}

\section{Safety and Liveness properties}
When building distributed system two fundamental concepts of computer science 
frequently appears: Safety and Liveness. Therefore, the understanding of these concepts 
has proven useful in testing and developing the different mutex algorithms.

% \subsection{Safety}
A safety property guarantees that something bad will never happen. It's a 
property that states that the system will not reach a bad or undesirable state. 

During the development of the algorithms this is why fuzzy testing technique has 
been used in \ref{subsubsec:basic_hypothesis_tests} and \ref{subsubsec:stateful_testing}
in order to assure that there is no race condition where two clients can be in
the critical section at the same time.

% \subsection{Liveness}
 A liveness property guarantees that something good will eventually happen. 
 This means that the system will eventually reach a desirable or good state.

While working on the development of the prototype, we encountered an issue where 
simultaneous requests were made by two clients to access the same critical section. 
To ensure system liveness and preempt a potential deadlock situation, we implemented 
a strategy that used the clients' IDs as a deciding factor, or 'tiebreaker', to 
determine which request would be processed first.
 
\section{Token Ring}
Token ring initially is a computer networking technology introduced by IBM 
to build local area network \cite{wiki_token_ring}. The token ring can be used 
to describe the physical or logical topology, in this specific project since 
the nodes are all just different process running on local host, the term will be
used to describe the logical topology.

\subsection{Topology of the token ring}
The token ring algorithm is the simplest conceptually of the three since it works 
by first arranging the node in a circular ring and then a random node is given a 
token. This token is continuously pass around the ring in one direction as shown in
\ref{fig:token_ring_top}

\begin{figure}[htbp]
  \centering
  \includesvg{images/token_ring.svg}
  \caption{Token ring's topology}
  \label{fig:token_ring_top}
\end{figure}

\subsection{How the algorithm works}
In the prototype's implementation of token ring, when the client wants to enter 
the critical section it first changes its internal state from its DEFAULT state to 
REQUESTING.

Then there are three scenarios:

\begin{itemize}
  \item Client does not have token, do nothing and wait.
  \item Client does have the token but is not interested in entering the critical section, pass the token to the next client in the ring.
  \item Client does have the token and is also interested in entering the critical section, keep the token and enter the critical section.
\end{itemize}

While the token ring concept is relatively straightforward to grasp among the three algorithms we implemented in this prototype, it proved to be the most challenging in terms of practical implementation. Initially, we struggled to devise a method that allowed for the token to be passed without impeding the process responsible for its transmission. We managed to overcome this hurdle by creating a separate event loop tasked exclusively with handling the token-passing process.

\section{Ricart Agrawala}
The Ricart-Agrawala Algorithm is a permission-based method for ensuring mutual 
exclusion in a distributed system.

The beauty of the Ricart-Agrawala Algorithm lies in its democratic nature. No 
single process or node has overarching control or authority; rather, each process 
gets to have its turn at accessing the shared resource, while all the others are 
aware of who is in the critical section at any given time. This is achieved using 
a method of requesting and granting permission for access, alongside a system of 
logical clocks to establish an order of precedence among simultaneous requests.

\subsection{Logical Clock}
In general the Ricart-Agrawala algorithm needs to need to know which action occur 
before another action. At first glance we might be tempted to use a normal clock, 
or called physical clock, where the time is just real work timestamp for each action, 
e.g. Unix epoch time, etc.

However, there is a problem with this approach, because 
distributed systems consist of numerous independent nodes, each operating on their 
own physical clock. These clocks, despite synchronization efforts, can differ 
slightly due to various factors such as drift and network latency. These minor 
variations can lead to substantial inconsistencies when it comes to deciding the 
sequence of events, particularly in algorithms like Ricart-Agrawala where mutual 
exclusion is governed by timestamps.


\begin{itemize}
  \item Physical clock: count the number of seconds that has passed
  \item Logical clock: count the number of events that has occurred
\end{itemize}

In the prototype implementation the logical clock is a counter variable that updates
every time a message is sent or received.
\subsection{How the algorithm works}
If a process wants to enter a critical section, it will first ask every other 
process with a Request message, the other node if some certain conditions are fulfilled
will send a Reply. Once the process that sent the Request message has enough Replied
it will enter the critical section.

In Ricart Agrawala, a process that has received a Request from another process will only 
reply in either:

\begin{itemize}
  \item The process itself is neither requesting nor is the critical section
  \item If the process is also requesting, the received request timestamp is smaller than its own request's timestamp.
\end{itemize}

The two conditions above is illustrated in \ref{fig:ricart_agrawala_seq}.

\begin{figure}[htbp]
  \centering
  \includesvg{ricart_agrawala_sequence.svg}
  \caption{sequence diagram of Ricart Agrawala algorithm}
  \label{fig:ricart_agrawala_seq}
\end{figure}

When P1 sends \textit{Request (T1)} Process P2 immediately \textit{reply} because it has not made any request yet 
or is in any critical section. Process P1 now has 1/2 replies needed.

Process P2 then sends \textit{Request (T2)} this time the timestamp is T2 because after P2 received 
\textit{Request (T1)} it updates its logical clock to T2. 

Process P1, now sees two requests its own \textit{Request (T1)} and P2's \textit{Request (T2)}
but since \textit{Request (T1)} has a smaller timestamp it will not send a reply to P2, and store
the deferred reply in a queue.

P3 then send a \textit{reply} to P1, now P1 has 2/2 replies needed, so it enters the critical 
section. P3 also send a reply to P2, but P2 only has 1/2 replies, so it waits for its turn.

Once P1 exited the critical section, it sends a reply message to all the deferred replies,
in this case it sends a reply to P2, P2 now has 2/2 replies. 

P2 enter the critical section

\section{Maekawa}
Differing from the Ricart-Agrawala algorithm above the Maekawa algorithm is a quorum based 
approach. A quorum, or a voting set, is a subset of total processes. Maekawa algorithm
is like Ricart-Agrawala but instead of asking all other process it just ask the members within
its quorum, this reduced the number of message being exchanged, thus being more efficient.

\subsection{Minimal Quorum}
Each quorum in the Maekawa algorithm must satisfy the two following properties:

\begin{itemize}
 \item Intersection Property: Every pair of voting sets has at least one process in common. 
 \item Majority Rule: Each process is part of its own voting set.
\end{itemize}
The intersection property ensures mutual exclusion because whenever two processes 
attempt to enter their critical sections simultaneously, the common process in their voting sets will only grant permission to one of them, thereby preventing simultaneous entry.

The majority rule allows each process to assert control over its own execution, giving it the power to request access to a resource and then release it when done.

To reduce the message complexity of the algorithm it is best that we use a minmal 
quorum. According to \cite{eth_quorum}: A quorum system $S$ is called \textbf{minimal}
if $\forall Q_1, Q_2 \in S: Q_1 \not\subset Q_2$.



\subsection{How to create a minimal quorum}

One way to construct a minimal quorum is to use a grid-based approach.

The steps to construct a minimal quorum are as follows:

\begin{enumerate}
\item Arrange all the client nodes into a square of side length $\sqrt{n}$, where $n$ is the total number of nodes.
\item The minimal quorum of a node comprises all the clients in the same row 
  and column as that node. An illustration of this is shown in Figure 
  \ref{fig:maekawa_minimal}, where the minimal quorum of client 1 is the set $\{1,2,4\}$.
\item Repeat the previous step for all clients.
\end{enumerate}


\begin{figure}[htbp]
  \centering
  \includesvg{maekawa_minimal_quorum.svg}
  \caption{Minimal quorum}
  \label{fig:maekawa_minimal}
\end{figure}


If the number of nodes, $n$, is not a perfect square, then some cells in the grid may be empty. Any such empty cells are not included in the quorum.\\

The details of how the algorithm operates have been omitted, as it functions in a manner similar to the Ricart-Agrawala algorithm. However, instead of requesting all nodes in the network to enter the critical section, the Maekawa algorithm only requests nodes within the same quorum.


